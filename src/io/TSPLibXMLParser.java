/**
 * 
 */
package io;

import java.io.File;
import java.io.IOException;
import java.util.LinkedList;
import java.util.List;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import tour.Edge;
import tspdef.AdjacencyMatrix;

/**
 * @author sg
 *
 */
public class TSPLibXMLParser {
	private AdjacencyMatrix adjacencyMatrix;
	
	/**
	 * Creates a {@link TSPLibXMLParser}.
	 * 
	 * The XML files were generated by Ulrich Pferschy and Rostislav Stanek
	 * from the University of Graz. They are available at :
	 * http://www.iwr.uni-heidelberg.de/groups/comopt/software/TSPLIB95/XML-TSPLIB/instances/
	 * 
	 * @param inputFileName The input TSP instance (as an XML file)
	 */
	public TSPLibXMLParser(String inputFileName) {
		try {
			// Taken from
			// www.mkyong.com/java/how-to-read-xml-file-in-java-dom-parser/
			File fXmlFile = new File(inputFileName);
			DocumentBuilderFactory dbFactory 
				= DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse(fXmlFile);
 
			//optional, but recommended
			//read this - 
			// http://stackoverflow.com/questions/13786607
			//		/normalization-in-dom-parsing-with-java-how-does-it-work
			doc.getDocumentElement().normalize(); 

			// Read in the name element.
			Element name = (Element) doc.getElementsByTagName("name").item(0);
			System.out.println(name.getChildNodes().item(0).getNodeValue());
			
			// Print a description.
			Element desc 
				= (Element) doc.getElementsByTagName("description").item(0);
			System.out.println(desc.getChildNodes().item(0).getNodeValue());
			
			// Now to the dirty work.
			// Read in the graph element to form the adjacency matrix.
			Element graph 
				= (Element) doc.getElementsByTagName("graph").item(0);
			NodeList vertexNodes = graph.getElementsByTagName("vertex");
			
			List<Edge> edges = new LinkedList<Edge>();
			for (short i = 0; i < vertexNodes.getLength(); ++i) {
				Element vNode = (Element) vertexNodes.item(i);
				NodeList edgeNodes = vNode.getElementsByTagName("edge");
				
				/* The input only has edges to other vertices, which makes
				 * sense.
				 * But I am using an adjacency matrix representation.
				 * To keep it simpler elsewhere, I'm adding dummy self-loops
				 * of cost 0.
				 */
				for (short j = 0; j < i; ++j) {
					Element eNode = (Element) edgeNodes.item(j);					
					int cost = nint(Float.parseFloat(
									eNode.getAttribute("cost")));
					short other = Short.parseShort(eNode.getChildNodes()
												  		.item(0)
												  		.getNodeValue());
					edges.add(new Edge(i, other, cost));
				}
				
				// Add the dummy edge.
				edges.add(new Edge(i, i, 0));

				for (short j = i; j < edgeNodes.getLength(); ++j) {
					Element eNode = (Element) edgeNodes.item(j);					
					int cost = nint(Float.parseFloat(
									eNode.getAttribute("cost")));
					short other = Short.parseShort(eNode.getChildNodes()
												  		.item(0)
												  		.getNodeValue());
					edges.add(new Edge(i, other, cost));
				}
			}
			
			Edge[] edgeArray = new Edge[edges.size()];
			edges.toArray(edgeArray);			
			this.adjacencyMatrix 
				= new AdjacencyMatrix((short) vertexNodes.getLength(),
									  edgeArray);
			
		} catch (ParserConfigurationException e) {
			e.printStackTrace();
		} catch (SAXException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Nearest integer function
	 * @param f float
	 * @return nearest int to f
	 */
	private int nint(float f) {
		return (int) (f + 0.5);
	}
	
	/**
	 * @return the adjacencyMatrix
	 */
	public AdjacencyMatrix getAdjacencyMatrix() {
		return adjacencyMatrix;
	}	
}
